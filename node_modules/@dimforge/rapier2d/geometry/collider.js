import { RotationOps, VectorOps } from '../math';
import { CoefficientCombineRule } from '../dynamics';
import { Cuboid, Ball, Capsule, TriMesh, Polyline, Heightfield, Segment, Triangle, RoundTriangle, RoundCuboid, 
// #if DIM2
ConvexPolygon, RoundConvexPolygon,
// #endif
 } from './shape';
/// Flags affecting whether or not collision-detection happens between two colliders
/// depending on the type of rigid-bodies they are attached to.
export var ActiveCollisionTypes;
(function (ActiveCollisionTypes) {
    /// Enable collision-detection between a collider attached to a dynamic body
    /// and another collider attached to a dynamic body.
    ActiveCollisionTypes[ActiveCollisionTypes["DYNAMIC_DYNAMIC"] = 1] = "DYNAMIC_DYNAMIC";
    /// Enable collision-detection between a collider attached to a dynamic body
    /// and another collider attached to a kinematic body.
    ActiveCollisionTypes[ActiveCollisionTypes["DYNAMIC_KINEMATIC"] = 12] = "DYNAMIC_KINEMATIC";
    /// Enable collision-detection between a collider attached to a dynamic body
    /// and another collider attached to a static body (or not attached to any body).
    ActiveCollisionTypes[ActiveCollisionTypes["DYNAMIC_STATIC"] = 2] = "DYNAMIC_STATIC";
    /// Enable collision-detection between a collider attached to a kinematic body
    /// and another collider attached to a kinematic body.
    ActiveCollisionTypes[ActiveCollisionTypes["KINEMATIC_KINEMATIC"] = 52224] = "KINEMATIC_KINEMATIC";
    /// Enable collision-detection between a collider attached to a kinematic body
    /// and another collider attached to a static body (or not attached to any body).
    ActiveCollisionTypes[ActiveCollisionTypes["KINEMATIC_STATIC"] = 8704] = "KINEMATIC_STATIC";
    /// Enable collision-detection between a collider attached to a static body (or
    /// not attached to any body) and another collider attached to a static body (or
    /// not attached to any body).
    ActiveCollisionTypes[ActiveCollisionTypes["STATIC_STATIC"] = 32] = "STATIC_STATIC";
    /// The default active collision types, enabling collisions between a dynamic body
    /// and another body of any type, but not enabling collisions between two non-dynamic bodies.
    ActiveCollisionTypes[ActiveCollisionTypes["DEFAULT"] = 15] = "DEFAULT";
    /// Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).
    ActiveCollisionTypes[ActiveCollisionTypes["ALL"] = 60943] = "ALL";
})(ActiveCollisionTypes || (ActiveCollisionTypes = {}));
/**
 * A geometric entity that can be attached to a body so it can be affected
 * by contacts and proximity queries.
 */
var Collider = /** @class */ (function () {
    function Collider(rawSet, handle) {
        this.rawSet = rawSet;
        this.handle = handle;
    }
    /**
     * Checks if this collider is still valid (i.e. that it has
     * not been deleted from the collider set yet.
     */
    Collider.prototype.isValid = function () {
        return this.rawSet.contains(this.handle);
    };
    /**
     * The world-space translation of this rigid-body.
     */
    Collider.prototype.translation = function () {
        return VectorOps.fromRaw(this.rawSet.coTranslation(this.handle));
    };
    /**
     * The world-space orientation of this rigid-body.
     */
    Collider.prototype.rotation = function () {
        return RotationOps.fromRaw(this.rawSet.coRotation(this.handle));
    };
    /**
     * Is this collider a sensor?
     */
    Collider.prototype.isSensor = function () {
        return this.rawSet.coIsSensor(this.handle);
    };
    Collider.prototype.setSensor = function (isSensor) {
        this.rawSet.coSetSensor(this.handle, isSensor);
    };
    Collider.prototype.setShape = function (shape) {
        var rawShape = shape.intoRaw();
        this.rawSet.coSetShape(this.handle, rawShape);
        rawShape.free();
    };
    /**
     * Sets the restitution coefficient of the collider to be created.
     *
     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior
     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the
     *                   constraints solver).
     */
    Collider.prototype.setRestitution = function (restitution) {
        this.rawSet.coSetRestitution(this.handle, restitution);
    };
    /**
     * Sets the friction coefficient of the collider to be created.
     *
     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The
     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider
     *                   being built.
     */
    Collider.prototype.setFriction = function (friction) {
        this.rawSet.coSetFriction(this.handle, friction);
    };
    /**
     * Gets the rule used to combine the friction coefficients of two colliders
     * colliders involved in a contact.
     */
    Collider.prototype.frictionCombineRule = function () {
        return this.rawSet.coFrictionCombineRule(this.handle);
    };
    /**
     * Sets the rule used to combine the friction coefficients of two colliders
     * colliders involved in a contact.
     *
     * @param rule − The combine rule to apply.
     */
    Collider.prototype.setFrictionCombineRule = function (rule) {
        this.rawSet.coSetFrictionCombineRule(this.handle, rule);
    };
    /**
     * Gets the rule used to combine the restitution coefficients of two colliders
     * colliders involved in a contact.
     */
    Collider.prototype.restitutionCombineRule = function () {
        return this.rawSet.coRestitutionCombineRule(this.handle);
    };
    /**
     * Sets the rule used to combine the restitution coefficients of two colliders
     * colliders involved in a contact.
     *
     * @param rule − The combine rule to apply.
     */
    Collider.prototype.setRestitutionCombineRule = function (rule) {
        this.rawSet.coSetRestitutionCombineRule(this.handle, rule);
    };
    /**
     * Sets the collision groups used by this collider.
     *
     * Two colliders will interact iff. their collision groups are compatible.
     * See the documentation of `InteractionGroups` for details on teh used bit pattern.
     *
     * @param groups - The collision groups used for the collider being built.
     */
    Collider.prototype.setCollisionGroups = function (groups) {
        this.rawSet.coSetCollisionGroups(this.handle, groups);
    };
    /**
     * Sets the solver groups used by this collider.
     *
     * Forces between two colliders in contact will be computed iff their solver
     * groups are compatible.
     * See the documentation of `InteractionGroups` for details on the used bit pattern.
     *
     * @param groups - The solver groups used for the collider being built.
     */
    Collider.prototype.setSolverGroups = function (groups) {
        this.rawSet.coSetSolverGroups(this.handle, groups);
    };
    /**
     * Get the physics hooks active for this collider.
     */
    Collider.prototype.activeHooks = function () {
        this.rawSet.coActiveHooks(this.handle);
    };
    /**
     * Set the physics hooks active for this collider.
     *
     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.
     *
     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.
     */
    Collider.prototype.setActiveHooks = function (activeHooks) {
        this.rawSet.coSetActiveHooks(this.handle, activeHooks);
    };
    /**
     * The events active for this collider.
     */
    Collider.prototype.activeEvents = function () {
        return this.rawSet.coActiveEvents(this.handle);
    };
    /**
     * Set the events active for this collider.
     *
     * Use this to enable contact and/or intersection event reporting for this collider.
     *
     * @param activeEvents - The events active for contact/intersection pairs involving this collider.
     */
    Collider.prototype.setActiveEvents = function (activeEvents) {
        this.rawSet.coSetActiveEvents(this.handle, activeEvents);
    };
    /**
     * Gets the collision types active for this collider.
     */
    Collider.prototype.activeCollisionTypes = function () {
        return this.rawSet.coActiveCollisionTypes(this.handle);
    };
    /**
     * Set the collision types active for this collider.
     *
     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.
     */
    Collider.prototype.setActiveCollisionTypes = function (activeCollisionTypes) {
        this.rawSet.coSetActiveCollisionTypes(this.handle, activeCollisionTypes);
    };
    /**
     * Sets the translation of this collider.
     *
     * @param tra - The world-space position of the collider.
     */
    Collider.prototype.setTranslation = function (tra) {
        // #if DIM2
        this.rawSet.coSetTranslation(this.handle, tra.x, tra.y);
        // #endif
    };
    /**
     * Sets the translation of this collider relative to its parent rigid-body.
     *
     * Does nothing if this collider isn't attached to a rigid-body.
     *
     * @param tra - The new translation of the collider relative to its parent.
     */
    Collider.prototype.setTranslationWrtParent = function (tra) {
        // #if DIM2
        this.rawSet.coSetTranslationWrtParent(this.handle, tra.x, tra.y);
        // #endif
    };
    // #if DIM2
    /**
     * Sets the rotation angle of this collider.
     *
     * @param angle - The rotation angle, in radians.
     */
    Collider.prototype.setRotation = function (angle) {
        this.rawSet.coSetRotation(this.handle, angle);
    };
    /**
     * Sets the rotation angle of this collider relative to its parent rigid-body.
     *
     * Does nothing if this collider isn't attached to a rigid-body.
     *
     * @param angle - The rotation angle, in radians.
     */
    Collider.prototype.setRotationWrtParent = function (angle) {
        this.rawSet.coSetRotationWrtParent(this.handle, angle);
    };
    // #endif
    /**
     * The type of the shape of this collider.
     */
    Collider.prototype.shapeType = function () {
        return this.rawSet.coShapeType(this.handle);
    };
    /**
     * The half-extents of this collider if it is a cuboid shape.
     */
    Collider.prototype.halfExtents = function () {
        return VectorOps.fromRaw(this.rawSet.coHalfExtents(this.handle));
    };
    /**
     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.
     */
    Collider.prototype.radius = function () {
        return this.rawSet.coRadius(this.handle);
    };
    /**
     * The radius of the round edges of this collider if it is a round cylinder.
     */
    Collider.prototype.roundRadius = function () {
        return this.rawSet.coRoundRadius(this.handle);
    };
    /**
     * The half height of this collider if it is a cylinder, capsule, or cone shape.
     */
    Collider.prototype.halfHeight = function () {
        return this.rawSet.coHalfHeight(this.handle);
    };
    /**
     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,
     * this returns the vertex buffer of said shape.
     */
    Collider.prototype.vertices = function () {
        return this.rawSet.coVertices(this.handle);
    };
    /**
     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,
     * this returns the index buffer of said shape.
     */
    Collider.prototype.indices = function () {
        return this.rawSet.coIndices(this.handle);
    };
    /**
     * If this collider has a heightfield shape, this returns the heights buffer of
     * the heightfield.
     * In 3D, the returned height matrix is provided in column-major order.
     */
    Collider.prototype.heightfieldHeights = function () {
        return this.rawSet.coHeightfieldHeights(this.handle);
    };
    /**
     * If this collider has a heightfield shape, this returns the scale
     * applied to it.
     */
    Collider.prototype.heightfieldScale = function () {
        var scale = this.rawSet.coHeightfieldScale(this.handle);
        return VectorOps.fromRaw(scale);
    };
    /**
     * The unique integer identifier of the rigid-body this collider is attached to.
     */
    Collider.prototype.parent = function () {
        return this.rawSet.coParent(this.handle);
    };
    /**
     * The friction coefficient of this collider.
     */
    Collider.prototype.friction = function () {
        return this.rawSet.coFriction(this.handle);
    };
    /**
     * The density of this collider.
     */
    Collider.prototype.density = function () {
        return this.rawSet.coDensity(this.handle);
    };
    /**
     * The collision groups of this collider.
     */
    Collider.prototype.collisionGroups = function () {
        return this.rawSet.coCollisionGroups(this.handle);
    };
    /**
     * The solver groups of this collider.
     */
    Collider.prototype.solverGroups = function () {
        return this.rawSet.coSolverGroups(this.handle);
    };
    return Collider;
}());
export { Collider };
var ColliderDesc = /** @class */ (function () {
    /**
     * Initializes a collider descriptor from the collision shape.
     *
     * @param shape - The shape of the collider being built.
     */
    function ColliderDesc(shape) {
        this.shape = shape;
        this.useMassProps = false;
        this.density = 1.0;
        this.friction = 0.5;
        this.restitution = 0.0;
        this.rotation = RotationOps.identity();
        this.translation = VectorOps.zeros();
        this.isSensor = false;
        this.collisionGroups = 4294967295;
        this.solverGroups = 4294967295;
        this.frictionCombineRule = CoefficientCombineRule.Average;
        this.restitutionCombineRule = CoefficientCombineRule.Average;
        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;
        this.activeEvents = 0;
        this.activeHooks = 0;
        this.mass = 0.0;
        this.centerOfMass = VectorOps.zeros();
        // #if DIM2
        this.principalAngularInertia = 0.0;
        this.rotationsEnabled = true;
        // #endif
    }
    /**
     * Create a new collider descriptor with a ball shape.
     *
     * @param radius - The radius of the ball.
     */
    ColliderDesc.ball = function (radius) {
        var shape = new Ball(radius);
        return new ColliderDesc(shape);
    };
    /**
     * Create a new collider descriptor with a capsule shape.
     *
     * @param halfHeight - The half-height of the capsule, along the `y` axis.
     * @param radius - The radius of the capsule basis.
     */
    ColliderDesc.capsule = function (halfHeight, radius) {
        var shape = new Capsule(halfHeight, radius);
        return new ColliderDesc(shape);
    };
    /**
     * Creates a new segment shape.
     *
     * @param a - The first point of the segment.
     * @param b - The second point of the segment.
     */
    ColliderDesc.segment = function (a, b) {
        var shape = new Segment(a, b);
        return new ColliderDesc(shape);
    };
    /**
     * Creates a new triangle shape.
     *
     * @param a - The first point of the triangle.
     * @param b - The second point of the triangle.
     * @param c - The third point of the triangle.
     */
    ColliderDesc.triangle = function (a, b, c) {
        var shape = new Triangle(a, b, c);
        return new ColliderDesc(shape);
    };
    /**
     * Creates a new triangle shape with round corners.
     *
     * @param a - The first point of the triangle.
     * @param b - The second point of the triangle.
     * @param c - The third point of the triangle.
     * @param borderRadius - The radius of the borders of this triangle. In 3D,
     *   this is also equal to half the thickness of the triangle.
     */
    ColliderDesc.roundTriangle = function (a, b, c, borderRadius) {
        var shape = new RoundTriangle(a, b, c, borderRadius);
        return new ColliderDesc(shape);
    };
    /**
     * Creates a new collider descriptor with a polyline shape.
     *
     * @param vertices - The coordinates of the polyline's vertices.
     * @param indices - The indices of the polyline's segments. If this is `null`,
     *    the vertices are assumed to describe a line strip.
     */
    ColliderDesc.polyline = function (vertices, indices) {
        var shape = new Polyline(vertices, indices);
        return new ColliderDesc(shape);
    };
    /**
     * Creates a new collider descriptor with a triangle mesh shape.
     *
     * @param vertices - The coordinates of the triangle mesh's vertices.
     * @param indices - The indices of the triangle mesh's triangles.
     */
    ColliderDesc.trimesh = function (vertices, indices) {
        var shape = new TriMesh(vertices, indices);
        return new ColliderDesc(shape);
    };
    // #if DIM2
    /**
     * Creates a new collider descriptor with a rectangular shape.
     *
     * @param hx - The half-width of the rectangle along its local `x` axis.
     * @param hy - The half-width of the rectangle along its local `y` axis.
     */
    ColliderDesc.cuboid = function (hx, hy) {
        var shape = new Cuboid(hx, hy);
        return new ColliderDesc(shape);
    };
    /**
     * Creates a new collider descriptor with a rectangular shape with round borders.
     *
     * @param hx - The half-width of the rectangle along its local `x` axis.
     * @param hy - The half-width of the rectangle along its local `y` axis.
     * @param borderRadius - The radius of the cuboid's borders.
     */
    ColliderDesc.roundCuboid = function (hx, hy, borderRadius) {
        var shape = new RoundCuboid(hx, hy, borderRadius);
        return new ColliderDesc(shape);
    };
    /**
     * Creates a new collider descriptor with a heightfield shape.
     *
     * @param heights - The heights of the heightfield, along its local `y` axis.
     * @param scale - The scale factor applied to the heightfield.
     */
    ColliderDesc.heightfield = function (heights, scale) {
        var shape = new Heightfield(heights, scale);
        return new ColliderDesc(shape);
    };
    /**
     * Computes the convex-hull of the given points and use the resulting
     * convex polygon as the shape for this new collider descriptor.
     *
     * @param points - The point that will be used to compute the convex-hull.
     */
    ColliderDesc.convexHull = function (points) {
        var shape = new ConvexPolygon(points, false);
        return new ColliderDesc(shape);
    };
    /**
     * Creates a new collider descriptor that uses the given set of points assumed
     * to form a convex polyline (no convex-hull computation will be done).
     *
     * @param vertices - The vertices of the convex polyline.
     */
    ColliderDesc.convexPolyline = function (vertices) {
        var shape = new ConvexPolygon(vertices, true);
        return new ColliderDesc(shape);
    };
    /**
     * Computes the convex-hull of the given points and use the resulting
     * convex polygon as the shape for this new collider descriptor. A
     * border is added to that convex polygon to give it round corners.
     *
     * @param points - The point that will be used to compute the convex-hull.
     * @param borderRadius - The radius of the round border added to the convex polygon.
     */
    ColliderDesc.roundConvexHull = function (points, borderRadius) {
        var shape = new RoundConvexPolygon(points, borderRadius, false);
        return new ColliderDesc(shape);
    };
    /**
     * Creates a new collider descriptor that uses the given set of points assumed
     * to form a round convex polyline (no convex-hull computation will be done).
     *
     * @param vertices - The vertices of the convex polyline.
     * @param borderRadius - The radius of the round border added to the convex polyline.
     */
    ColliderDesc.roundConvexPolyline = function (vertices, borderRadius) {
        var shape = new RoundConvexPolygon(vertices, borderRadius, true);
        return new ColliderDesc(shape);
    };
    // #endif
    // #if DIM2
    /**
     * Sets the position of the collider to be created relative to the rigid-body it is attached to.
     */
    ColliderDesc.prototype.setTranslation = function (x, y) {
        if (typeof x != "number" || typeof y != "number")
            throw TypeError("The translation components must be numbers.");
        this.translation = { x: x, y: y };
        return this;
    };
    // #endif
    /**
     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.
     *
     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.
     */
    ColliderDesc.prototype.setRotation = function (rot) {
        this.rotation = rot;
        return this;
    };
    /**
     * Sets whether or not the collider being created is a sensor.
     *
     * A sensor collider does not take part of the physics simulation, but generates
     * proximity events.
     *
     * @param is - Set to `true` of the collider built is to be a sensor.
     */
    ColliderDesc.prototype.setSensor = function (is) {
        this.isSensor = is;
        return this;
    };
    /**
     * Sets the density of the collider being built.
     *
     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider
     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.
     */
    ColliderDesc.prototype.setDensity = function (density) {
        this.useMassProps = false;
        this.density = density;
        return this;
    };
    // #if DIM2
    /**
     * Sets the mass properties of the collider being built.
     *
     * This replaces the mass-properties automatically computed from the collider's density and shape.
     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.
     *
     * @param mass − The mass of the collider to create.
     * @param centerOfMass − The center-of-mass of the collider to create.
     * @param principalAngularInertia − The principal angular inertia of the collider to create.
     */
    ColliderDesc.prototype.setMassProperties = function (mass, centerOfMass, principalAngularInertia) {
        this.useMassProps = true;
        this.mass = mass;
        this.centerOfMass = centerOfMass;
        this.principalAngularInertia = principalAngularInertia;
        return this;
    };
    // #endif
    /**
     * Sets the restitution coefficient of the collider to be created.
     *
     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior
     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the
     *                   constraints solver).
     */
    ColliderDesc.prototype.setRestitution = function (restitution) {
        this.restitution = restitution;
        return this;
    };
    /**
     * Sets the friction coefficient of the collider to be created.
     *
     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The
     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider
     *                   being built.
     */
    ColliderDesc.prototype.setFriction = function (friction) {
        this.friction = friction;
        return this;
    };
    /**
     * Sets the rule used to combine the friction coefficients of two colliders
     * colliders involved in a contact.
     *
     * @param rule − The combine rule to apply.
     */
    ColliderDesc.prototype.setFrictionCombineRule = function (rule) {
        this.frictionCombineRule = rule;
        return this;
    };
    /**
     * Sets the rule used to combine the restitution coefficients of two colliders
     * colliders involved in a contact.
     *
     * @param rule − The combine rule to apply.
     */
    ColliderDesc.prototype.setRestitutionCombineRule = function (rule) {
        this.restitutionCombineRule = rule;
        return this;
    };
    /**
     * Sets the collision groups used by this collider.
     *
     * Two colliders will interact iff. their collision groups are compatible.
     * See the documentation of `InteractionGroups` for details on teh used bit pattern.
     *
     * @param groups - The collision groups used for the collider being built.
     */
    ColliderDesc.prototype.setCollisionGroups = function (groups) {
        this.collisionGroups = groups;
        return this;
    };
    /**
     * Sets the solver groups used by this collider.
     *
     * Forces between two colliders in contact will be computed iff their solver
     * groups are compatible.
     * See the documentation of `InteractionGroups` for details on the used bit pattern.
     *
     * @param groups - The solver groups used for the collider being built.
     */
    ColliderDesc.prototype.setSolverGroups = function (groups) {
        this.solverGroups = groups;
        return this;
    };
    /**
     * Set the physics hooks active for this collider.
     *
     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.
     *
     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.
     */
    ColliderDesc.prototype.setActiveHooks = function (activeHooks) {
        this.activeHooks = activeHooks;
        return this;
    };
    /**
     * Set the events active for this collider.
     *
     * Use this to enable contact and/or intersection event reporting for this collider.
     *
     * @param activeEvents - The events active for contact/intersection pairs involving this collider.
     */
    ColliderDesc.prototype.setActiveEvents = function (activeEvents) {
        this.activeEvents = activeEvents;
        return this;
    };
    /**
     * Set the collision types active for this collider.
     *
     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.
     */
    ColliderDesc.prototype.setActiveCollisionTypes = function (activeCollisionTypes) {
        this.activeCollisionTypes = activeCollisionTypes;
        return this;
    };
    return ColliderDesc;
}());
export { ColliderDesc };
//# sourceMappingURL=collider.js.map